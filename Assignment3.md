# Assignment 3 - Extracting quality score summaries from a FASTQ file

## Background
There are now several web applications and stand-alone apps that will summarize the base quality in a FASTQ file, but it wasn't that long ago that the best option was to do it yourself.  It is still helpful to be able to do this yourself, not only because data formats are inevitably going to change, but also because you should never have to rely on someone else's program when you don't know what it's doing.  

## Data
For this assignment, we're going to download a relatively small FASTQ file generated by an Illumina MiSeq from a paired-end library targeting circulating tumor DNA ([source](https://www.ncbi.nlm.nih.gov/sra/ERX948700[accn])).  This sample came from a patient suffering from [non-small-cell lung carcinoma](https://en.wikipedia.org/wiki/Non-small-cell_lung_carcinoma), and was uploaded by the [Cancer Research UK Cambridge Institute](http://www.cruk.cam.ac.uk/).  

I've uploaded the file to the `examples` folder as `ERR869099.fastq.gz`.  The `.gz` suffix means that this is a binary file that is the result of compressing the original FASTQ file using the GNU program [gzip](https://en.wikipedia.org/wiki/Gzip).  I compressed the file because it is generally a bad idea to upload large binary files to a version control repository like GitHub.  

Please submit your completed assignment as a Markdown file to me by e-mail, using the following section as a template.

## Problems
1. Use a UNIX command to determine how large this compressed file is in bytes.  Show the command you used.  Next, uncompress the file using the command `gunzip -k ERR869099.fastq.gz` (the `-k` flag keeps the original file) and use the same command to see how the file size has changed.  By what factor did the file size increase?
```
simon@BioLinux-Simon[examples] ls -l ERR*                             [10:45PM]
-rw-rw-r-- 1 simon simon 1606279 Jun  5 22:01 ERR869099.fastq.gz
simon@BioLinux-Simon[examples] gunzip -k ERR869099.fastq.gz           [10:45PM]
simon@BioLinux-Simon[examples] ls -l ERR*                             [10:46PM]
-rw-rw-r-- 1 simon simon 7206316 Jun  5 22:01 ERR869099.fastq
-rw-rw-r-- 1 simon simon 1606279 Jun  5 22:01 ERR869099.fastq.gz

#The file is about 4.5 times larger (7206316 bytes vs. 1606279)


```

2. How many records are in the uncompressed FASTQ file?

```
simon@BioLinux-Simon[examples] wc -l ERR869099.fastq                 [11:04PM]
43288 ERR869099.fastq

#As FastQ files have 4 lines per record the number of records should be 10822 (43288 divided by 4)

#To verify I used grep to count the number of instances of the header row in the file as well

simon@BioLinux-Simon[examples] grep -c "@ERR" ERR869099.fastq        [11:10PM]
10822



```

3. During class, you'll have already written a script for parsing a FASTQ file, including a function that converts the ASCII quality string into a vector of integer-valued scores.  The primary objective of this assignment is to tabulate the quality scores at each read position and then report the number in each cell as a CSV file.  The end result should correspond to something like this table:
  
  |pos|0|1|2|...|39|40|41|
  |---|-|-|-|---|--|--|--|
  | 1 |1|15|13|   |69|53| 3|
  | 2 |0|6|7|   |178|80|22|
  | 3 |0|0|0|   |1005|309|178|
  |...| | | |   |  |  |  |
  |299|16|55|101|   | 0| 0| 0|
  |300|68|89|121|   | 0| 0| 0|
  
  where each row represents a position in the read (every read is 300 nucleotides long) and the columns (starting from the 2nd onwards) correspond to the possible quality scores.
  
  A good way to proceed is to use a dictionary.  I would build a dictionary with integer keys from `0` to `41`, and have each key associated with a list as its value.  Each list can be a vector of 300 zeros.  To build such a list, you can use this expression: `[0]*300`.  I highly recommend using a `for` loop to build up from an empty dictionary with the `update` function.  I also recommend writing a function to initialize this dictionary.  Think hard about where you want to call this function in your code.
  
  The way this should work is that for every record generated by your `parse_fastq` function, you can iterate over its vector of quality score, use each score to key into your dictionary, and the current position to index into the vector.  Increment that member of the vector using this notation: `vector[i] += 1`.  Remember that `vector` and `i` are just variable names, and you can choose any name you want (as long as it obeys the Python rules).
  
  
